# 第三章： 闭包和高阶函数

## 1. 闭包

闭包的形成与变量的作用域以及变量的生存周期密切相关

### 1.1 变量的作用域

1）变量的作用域是指变量的作用范围，首先在全局域中的变量叫做全局变量，没有 var 的变量也是全局变量，
2）全局变量属于window，在JavaScript中，函数可以创建函数作用域，里面的变量叫做局部变量；
3）在函数作用域中，内部可以沿着作用域链，向外部查找，而外部的找不到内部的；

### 1.2 变量的生存周期

1） 一般来说，全局作用域的变量是永久存在的，除非主动销毁，而函数作用域里的变量，在函数执行完毕以后，就会销毁，不过闭包是个例外；

例：
```
    <script>
        var func = function () {
            var a = 1;
            return function () {
                a++;
                alert(a);
            }
        };
        var f = func();
        f(); // 2
        f(); // 3
        f(); // 4
    </script>
```

在这里虽然，func 执行结束了，但是变量a并没有销毁；
因为，在执行func的时候，返回一个匿名函数引用，而这个匿名函数可以通过作用域链访问到外部的作用域，由于外部作用域依旧可以访问，所以a不会被销毁，这就形成了一个闭包，延长了func中的变量；

闭包的经典应用：

```
    <script>
        var div = document.getElementsByTagName('div');
        for (var i = 0; i < div.length; i++) {
            ;(function(index){
                div[index].onclick = function () {
                    alert(index)
                }
            })(i);
        }
    </script>
```

扩展：
用于数据类型判断，主要是用了toString的方式；
```
    var Type = {};
    for ( var i = 0, type; type = ["String", "Array", "Number", "Object"][i++];) {
        ;(function(type){
            Type['is' + type] = function (obj) {
                return Object.prototype.toString.call(obj) == '[object '+ type +']';
            }
        })(type);
    }
```

这是个很有意思的方法，
1. 使用了独特的for循环，简化了代码
2. 通过循环和闭包的配合一次性完成了方法的配置；
3. 返回一个布尔值；

### 1.3 闭包的更多作用

总之闭包很重要；

#### 1.3.1 封装变量

将一些不需要暴露在外的变量，变成一个私有变量；

实例：
一个简单的连乘；
```
    <script>
        function mult () {
            var a = 1;
            for (var i = 0; i < arguments.length; i++) {
                a = a * arguments[i];
            }
            return a;
        }
        var a = mult(10,12,11);
        alert(a)
    </script>
```

改进后：

```
    var cache = {};
        function mult () {
            var args = Array.prototype.join.call(arguments, ',');
            if (cache[args]) {
                return cache[args];
            } else {
                var a = 1;
                for (var i = 0; i < arguments.length; i++) {
                    a = a * arguments[i];
                }
                cache[args] = a;
                return a;
            }
        }

        alert(mult(10,11,12,13));
        alert(mult(10,11,12,13));
```

1. 这样做是为了不让已经计算过的再次计算，节省性能；但是cache仍旧暴露出来了

改进：

```
    var mult = (function () {
        var cache = {};
        return function () {
            var args = Array.prototype.join.call(arguments, ',');
            if (cache[args]) {
                return cache[args];
            } else {
                var a = 1;
                for (var i = 0; i < arguments.length; i++) {
                    a = a * arguments[i];
                }
                return cache[args] = a;
            }
        }
    })();

    alert(mult(10,11,12,13));
    alert(mult(10,11,12,13));
```

1. 这种方式，使用闭包将全部变量变私有变量，又通过执行，将需要使用的函数暴露出来；
2. 这里的函数必须使用字面量形式，因为返回的是一个匿名函数，必须要有变量接受；
3. ` return cache[args] = a;` 这里返回的是a；

提炼函数，如果一个大的代码块中的一些函数能够独立出来，最好将这些代码块封装成一个个小函数，这样便于管理和复用；如果这些小函数不在程序的其他地方运行的话，就把他们用闭包封装起来；

以上面的实例为例，其中 
```
    var a = 1;
    for (var i = 0; i < arguments.length; i++) {
        a = a * arguments[i];
    }
```

是不变的 应该使用一个函数包裹；

```
    <script>
        var mult = (function () {
            var cache = {};
            var cal = function () {
                var a = 1;
                for (var i = 0; i < arguments.length; i++) {
                    a = a * arguments[i];
                }
                return a;
            }
            return function () {
                var args = Array.prototype.join.call(arguments, ',')
                if (cache[args]) {
                    return cache[args];
                }
                return cache[args] = cal.apply(null, arguments);
            }
        })();
        alert(mult(1,3,45,1))
    </script>
```

1. 当将一个函数提取出来的时候，如果完全独立的话，就需要使用返回值，来与外部环境搭建关系；

#### 1.3.2 延续局部变量的寿命

先分析下面代码的问题：

```
    <script>
        var report = function (src) {
            var img = new Image();
            img.src = src;
        }

        report ('http...........')
    </script>
```

问题：丢包，也就是说当img还没有完全加载出来甚至还没呢发送请求的时候， 函数就执行完了， 其局部变量img就会销毁；

解决:
```
    var report = (function (src) {
        var imgs = [];
        return function () {
            var img = new Image();
            imgs.push(img);
            img.src = src;
        }
    })();

    report ('http...........')
```

1. 通过闭包使得imgs长存；

## 1.4 闭包和面向对象设计

对象以方法的形式包含了过程，而闭包以环境的方式包含了数据，而过程和数据的结合常被用来形容对象；

通常能够使用面向对象思想解决的都能够通过闭包来实现，反之亦然；

实例：

```
    <script>
        var extent = (function () {
            var value = 0;
            return {
                call: function () {
                    console.log(value++);
                }
            }
        })();
        var extent = extent.call;
        extent(); // 0
        extent(); // 1
        extent(); // 2
        extent(); // 3
    </script>
```

1. 这是一个使用闭包封闭数据的方式

同样可以使用面向对象的方式表示；
```
     function Extent () {
        this.value = 0;
    }
    Extent.prototype.call = function(){
        console.log(this.value++);
    };

    var extent = new Extent;

    extent.call();// 0
    extent.call();// 1
    extent.call();// 2
    extent.call();// 3
```

或者是另一种方式：

```
    var extent = {
        value: 0,
        call: function () {
            console.log(this.value++);
        }
    }
```

## 1.5 闭包实现命令模式：

```
    <script>
        /* 预先植入的命令 方法 */
        var Tv = {
            open: function () {
                console.log('打开');
            },
            close: function () {
                console.log('关闭');
            }
        }

        // 命令的接受者

        function OpenTvCommand (reserves) {
            this.reserves = reserves;
        }
        OpenTvCommand.prototype.execute = function(){
            this.reserves.open();
        };
        OpenTvCommand.prototype.undo = function(){
            this.reserves.close();
        };

        // 命令的发起者

        var setCommand = function (command) {
            document.getElementById('execute').onclick =function () {
                command.execute();
            },
            document.getElementById('undo').onclick =function () {
                command.undo();
            }
        }

        setCommand(new OpenTvCommand(Tv));
    </script>
```

1. 命令模式就是为了将请求的封装，从而分离，请求的发起着和请求的接受着；

2. 在命令被执行之前，可以预先向命令对象中添加命令的接受者；

3. 将命令对象被当成对象的属性保存来的；

4. 在JavaScript中，函数本就可以四处传递，使用函数对象直接传递要更简单一些，如果需要向函数对象中预先植入命令的接受者，那么闭包就可以完成这项工作，在面向对象中，命令是通过对象属性保存的，而在闭包中是依靠环境保存的

闭包式：

```
        var createCommand = function (receiver) {
            var execute = function () {
                return receiver.open();
            };
            var undo = function () {
                return receiver.close();
            };
            return {
                execute: execute,
                undo: undo
            }
        }

        setCommand(createCommand(Tv))
```

<a href="html/闭包实现命令模式.html">闭包实现命令模式</a>

## 1.6 闭包与内存管理：

闭包会造成内存泄漏【1】-- 当函数执行完后，局部变量没有销毁；但是有时使我们主动将全局变量放到闭包中，所以是在全局还是在局部对内存来说都没有太大的影响；而且如果需要将变量所占用的内存释放出来，只需要将变量赋值为null；

注：
 1. 内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏。

