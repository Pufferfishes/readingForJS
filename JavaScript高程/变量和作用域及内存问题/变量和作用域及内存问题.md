# 变量和作用域及内存问题
基本类型 || 引入类型 || 执行环境 || 垃圾收集

在 JS 中变量是一个松散类型，在脚本的声明周期中可以改变变量类型

## 1. 基本类型和引用类型

基本类型：
定义：简单的数据段
分类：Number、 undefined、 Null、 Boolean、 String
使用：按值访问
特点：
1. 不能添加属性和方法.
2. 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；

引入类型：
定义：由多个值构成的对象
分类：Object
使用：按址访问，在操作对象的时候，实际操作的是对象的引用而不是实际的值
特点：
1. 可以添加属性和方法；
2. 如果不删除就会一直存在，引用类型的值是对象，保存在堆内存中；
3. 包含引用类型的变量实际上包含的并不是对象本身，而不是一个执行该对象的指针；

### 1.1 复制变量值

[DOME1](././html/dome1.js)

从一个变量向另一个变量赋值基本类型的值，会创建这个值的一个副本；
在从一个变量向另一个变量复制时，基本类型和引入类型的表现也是不同的
基本类型：
当一个变量A去复制主变量B，这是会在变量对象上创建一个新值，然后再将该变量复制B的值最后放在为变量A分配的位置上；这样A和B保持相对独立，互不影响

引入类型：
当一个变量A去复制主变量B，会复制B的指针，然后传递给A，这样A和B实际上指向的是一个内存地址，所以当修改其中一个的时候，另一个就会跟着变化
```
var arr1 = [1,2,3]
var arr2 = arr1;
arr2.push('a');
console.log(arr1); //[ 1, 2, 3, 'a' ]
console.log(arr2); //[ 1, 2, 3, 'a' ]
```

### 1.2 传递参数

ECMAScript 中规定所有函数的参数都是按值传递的；
首先函数构建了一个局部作用域，在函数接收参数的时候，实际上是在局部作用域中创建了一个变量，存放传入的参数，并在函数执行结束后销毁；
在处理引入类型的参数时，在函数内部对整个引入类型的参数进行的修改，只会修改局部域中的新创建对象，并在函数执行后销毁，所以不会影响外部的对象；

### 1.3 检测类型

typeof || instanceof || toString

```
var typeArr = [12, {}, 'a', null, undefined, true]
for (var i = 0; i < typeArr.length; i++) {
    // console.log(typeof typeArr[i]); //number object string object undefined boolean
    console.log(Object.prototype.toString.call(typeArr[i]));
    //[object Number] [object Object] [object String] [object Null] [object Undefined] [object Boolean]
}

console.log(typeArr[1] instanceof Object)  //true
```

## 1.2 执行环境及作用域

执行环境是指变量或者函数有权访问的其他数据，决定了它们各自的行为
每一个执行环境都有一个与之观关联的变量对象，执行环境定义的所有变量和函数都保存在这个对象的，只是我们无法访问

全局执行环境 -- 由宿主决定，在浏览器中全局执行环境就是window
当一个执行环境中的所有代码都指向完毕后，就会销毁该执行环境，而其中的变量和函数也会销毁

每一个函数都是一个执行环境，当执行流进入一个环境中，函数的环境就会被推入一个环境栈中，而在函数执行结束以后，栈就将这个环境弹出，把控制权返回给上一个执行环境

作用域链：每一个执行环境都会创建一个作用域链，作用域链保证了执行环境对其能访问的函数和变量的访问顺序可序化
当查找一个变量的时候，会一级一级的沿着作用域链向上查找，直到全局执行环境，期间只要是找到了就立即停止查找；
>注：绝不会出现向下查找的情况

### 1.2.1 延长作用域链

### 1.2.2 没有块级作用域

1. 声明变量
通过 var 声明的变量，会绑到距离它最近的作用域上，如果没有 var 就会绑到全局执行环境中

2. 查询标识符

## 1.3 垃圾收集

JS 中具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存；在开发中无需关心内存的使用问题，所需的内存分配以及无用的内存回收完全实现了自动管理；

垃圾回收：垃圾回收器会按照固定的时间间隔，周期性的找出那些不在继续使用的变量，然后释放其占用的内存；

局部变量的正常的声明周期：局部变量只在函数执行的过程中存在，在函数执行的过程中，会再内存上为局部变量分配相应的空间，存储他的值，然后在函数中使用已经储存的变量，直到函数执行结束，在函数执行接受后，不在被使用的局部变量就不需要存在了，从而被垃圾回收机制处理，释放其所在的内存；但是对于如果识别无用的变量，存在两种策略

### 1.3.1 标记清除

JS 中常用的垃圾收集的方式是标记清除，当变量进入环境（变量被声明），那么这个变量就会被标记成‘进入环境’，当变量离开环境的时候，就将其标记成‘离开环境’；

标记变量的方式有许多种，其中：
垃圾回收机制在运行的时候会给存储在内存中的所有的变量添加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量上的标记，这时被标记的变量就会被视为准备被删除的变量（这些变量已经不能被执行环境访问），最后，垃圾回收机制就会销毁这些带有标记的变量，完成内存清除的工作

### 1.3.2 引用计数

现在使用这种垃圾回收策略并不常见，所以略作了解

被引用就 +1 ，如果引入的变量被重新赋值 就-1；如果成为了0 ，就意味着已经不能被执行环境访问，这样就会在下一次循环的时候被清除

### 1.3.3 性能问题

垃圾回收机制，是以一定间隔不断循环的，周期性行为，那么循环的间隔如何设置就涉及到性能问题了，在各个浏览器中实现的方式各有不同；

### 1.3.4 管理内存

在计算机中，为Web 浏览器分配的内存是有限的，内存限制不仅仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量；

所以，确保占用最少的内存可以让页面获得更好的性能，而优化内存占用的最佳方式，就是主动将变量脱离环境，也就是主动将不再使用的变量的值设置成null 来释放它的引用，这种方式叫做解除引用，这一做法适用于全局变量和全局对象的属性，以及被变量引入的局部变量；（没有被引入的局部变量会在它们离开执行环境的时候自动被解除）

注： 解除引用仅仅是解除引用，被解除的变量会在下一次垃圾回收的时候被释放；
