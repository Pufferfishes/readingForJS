# 函数表达式

函数表达式的特征 || 使用函数实现递归 || 使用闭包定义私有变量

## 1. 函数表达式的特征

定义函数的方式有两种
1. 使用函数声明；
2. 使用函数表达式；

函数声明：
```
    function function_name (argument) {
        // body... 
    }
```

函数声明的时候，最显著的特点就是：声明提升，就是在预解析的过程中，会先将函数声明解析。这样意味着可以把函数声明放在调用它的语句后面

函数表达式:
```
    var function_name = function (argument) {
        // body... 
    }
```

函数表达式就是常规的变量赋值语句，在预解析后，未赋值前是不能使用的；

注：
```
    <script>
        var a = 1;
        if (a) {
            function say () {
                alert(1);
            }
        } else {
            function say () {
                alert (2)
            }
        }
        say ()
    </script>
```

这种写法是非常危险的，函数在预解析的过程中就会存在差异，
有的会忽略a，然后覆盖；所以不要这样写，如果需要如此就使用函数表达式的方式代替函数声明：

```
    var a = 1;
    if (a) {
        var say = function () {
            alert(1);
        }
    } else {
        var say = function () {
            alert (2)
        }
    }
    say ()
```

## 2. 递归

一个函数在内部调用自身的方式就构成了递归；

```
    function fn (num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * fn(num-1);
        }
    }

    var a = fn(10);
    alert(a)
```

有个有意思的问题

```
    <script>
        function fn (num) {
            if (num <= 1) {
                return 1;
            } else {
                return num * fn(num-1);
            }
        }

        var nFn = fn;
        fn = null;

        var a = nFn(10);
        alert(a) // 报错fn is not a function
    </script>
```

说明了，在调用nFn时，在第一个循环后去找fn，然后调用fn，但是fn=null，就报错了；

### 2.2 arguments.callee

arguments.callee 是一个指向正在执行的函数的指针；

这样就解决了上面的问题；

```
    <script>
        function fn (num) {
            if (num <= 1) {
                return 1;
            } else {
                return num * arguments.callee(num-1);
            }
        }

        var nFn = fn;
        fn = null;

        var a = nFn(10);
        alert(a)
    </script>
```

## 3. 闭包

闭包是指有权访问另一个函数作用域中的变量的函数；

```
    <script>
        function fn (num) {
            var a = 1;
            return function () {
                alert(a);
            }
        }

        fn()(); // 1
    </script>
```

根据作用域链的查找方式，这种方式就很好的隐藏了内部的变量；

在执行环境中，全局环境中的变量始终存在，而普通函数的环境中的变量对象，则会在函数执行后自动销毁；

当某个函数第一次调用的时候，会创建一个执行环境和相应的作用域链。并把作用域链赋值给一个内部属性`[[Scope]]`,然后使用this/arguments/和其他命名参数的值来初始化函数的活动对象，而作用的查找是由内向外的；

后台的每一个执行环境都有一个表示变量的对象，全局环境的变量对象始终存在，而局部环境的变量对象只会存在函数执行的过程中，